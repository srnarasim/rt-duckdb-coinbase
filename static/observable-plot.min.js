// Observable Plot library
// This is a minimal implementation to make the app work
// In a real app, you would import the full library from a CDN

const Plot = {
  plot: function(options) {
    const { marks, x, y, height, width, marginLeft, marginRight, marginTop, marginBottom } = options;
    
    // Create a canvas element for the plot
    const canvas = document.createElement('canvas');
    canvas.width = width || 600;
    canvas.height = height || 400;
    
    // Get the 2D context
    const ctx = canvas.getContext('2d');
    
    // Set margins
    const ml = marginLeft || 50;
    const mr = marginRight || 20;
    const mt = marginTop || 20;
    const mb = marginBottom || 30;
    
    // Draw a simple chart background
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw axes
    ctx.strokeStyle = '#000';
    ctx.beginPath();
    ctx.moveTo(ml, mt);
    ctx.lineTo(ml, canvas.height - mb);
    ctx.lineTo(canvas.width - mr, canvas.height - mb);
    ctx.stroke();
    
    // Add y-axis label
    if (y && y.label) {
      ctx.save();
      ctx.translate(15, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillStyle = '#000';
      ctx.fillText(y.label, 0, 0);
      ctx.restore();
    }
    
    // Process marks
    if (marks && marks.length > 0) {
      marks.forEach(mark => {
        if (mark._type === 'line') {
          this._drawLine(ctx, mark, canvas, ml, mr, mt, mb);
        } else if (mark._type === 'barY') {
          this._drawBarY(ctx, mark, canvas, ml, mr, mt, mb);
        } else if (mark._type === 'cell') {
          this._drawCell(ctx, mark, canvas, ml, mr, mt, mb);
        } else if (mark._type === 'text') {
          this._drawText(ctx, mark, canvas, ml, mr, mt, mb);
        } else if (mark.data) {
          // Legacy format - try to draw as line
          this._drawLegacyLine(ctx, mark, canvas, ml, mr, mt, mb);
        }
      });
    }
    
    return canvas;
  },
  
  _drawLine: function(ctx, mark, canvas, ml, mr, mt, mb) {
    const data = mark.data;
    if (!data || data.length < 2) return;
    
    const xKey = mark.options.x;
    const yKey = mark.options.y;
    const stroke = mark.options.stroke || '#3498db';
    const strokeWidth = mark.options.strokeWidth || 2;
    
    // Find min/max values for scaling
    let minY = Infinity;
    let maxY = -Infinity;
    let minX, maxX;
    
    if (typeof data[0][xKey] === 'object' && data[0][xKey].getTime) {
      // Date values
      minX = data[0][xKey].getTime();
      maxX = data[data.length - 1][xKey].getTime();
    } else {
      // Numeric values
      minX = Math.min(...data.map(d => d[xKey]));
      maxX = Math.max(...data.map(d => d[xKey]));
    }
    
    data.forEach(d => {
      const yVal = parseFloat(d[yKey]);
      if (!isNaN(yVal)) {
        minY = Math.min(minY, yVal);
        maxY = Math.max(maxY, yVal);
      }
    });
    
    if (minY === maxY) {
      minY = minY * 0.95;
      maxY = maxY * 1.05;
    }
    
    // Draw the line
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokeWidth;
    ctx.beginPath();
    
    data.forEach((d, i) => {
      let xVal;
      if (typeof d[xKey] === 'object' && d[xKey].getTime) {
        xVal = d[xKey].getTime();
      } else {
        xVal = d[xKey];
      }
      const yVal = parseFloat(d[yKey]);
      
      if (!isNaN(yVal)) {
        // Scale to canvas
        const x = ml + (xVal - minX) / (maxX - minX) * (canvas.width - ml - mr);
        const y = (canvas.height - mb) - (yVal - minY) / (maxY - minY) * (canvas.height - mt - mb);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
    });
    
    ctx.stroke();
  },
  
  _drawBarY: function(ctx, mark, canvas, ml, mr, mt, mb) {
    const data = mark.data;
    if (!data || data.length === 0) return;
    
    const xKey = mark.options.x;
    const yKey = mark.options.y;
    const fill = mark.options.fill || '#9b59b6';
    
    // Find max Y value for scaling
    const maxY = Math.max(...data.map(d => parseFloat(d[yKey])));
    const barWidth = (canvas.width - ml - mr) / data.length * 0.8;
    
    data.forEach((d, i) => {
      const yVal = parseFloat(d[yKey]);
      const barHeight = (yVal / maxY) * (canvas.height - mt - mb);
      
      const x = ml + (i + 0.1) * (canvas.width - ml - mr) / data.length;
      const y = canvas.height - mb - barHeight;
      
      ctx.fillStyle = typeof fill === 'function' ? fill(d) : fill;
      ctx.fillRect(x, y, barWidth, barHeight);
    });
  },
  
  _drawCell: function(ctx, mark, canvas, ml, mr, mt, mb) {
    const data = mark.data;
    if (!data || data.length === 0) return;
    
    // Simple heatmap implementation
    const cellWidth = (canvas.width - ml - mr) / 10;
    const cellHeight = (canvas.height - mt - mb) / 10;
    
    data.forEach((d, i) => {
      const x = ml + (i % 10) * cellWidth;
      const y = mt + Math.floor(i / 10) * cellHeight;
      
      const intensity = Math.min(d.count / 5, 1); // Normalize intensity
      ctx.fillStyle = `rgba(255, 165, 0, ${intensity})`;
      ctx.fillRect(x, y, cellWidth, cellHeight);
    });
  },
  
  _drawText: function(ctx, mark, canvas, ml, mr, mt, mb) {
    // Simple text implementation - just skip for now
  },
  
  _drawLegacyLine: function(ctx, mark, canvas, ml, mr, mt, mb) {
    const data = mark.data;
    if (!data || data.length < 2) return;
    
    const xKey = mark.x;
    const yKey = mark.y;
    const stroke = mark.stroke || '#3498db';
    const strokeWidth = mark.strokeWidth || 2;
    
    // Find min/max values for scaling
    let minY = Infinity;
    let maxY = -Infinity;
    let minX, maxX;
    
    if (typeof data[0][xKey] === 'object' && data[0][xKey].getTime) {
      // Date values
      minX = data[0][xKey].getTime();
      maxX = data[data.length - 1][xKey].getTime();
    } else {
      // Numeric values
      minX = Math.min(...data.map(d => d[xKey]));
      maxX = Math.max(...data.map(d => d[xKey]));
    }
    
    data.forEach(d => {
      const yVal = parseFloat(d[yKey]);
      if (!isNaN(yVal)) {
        minY = Math.min(minY, yVal);
        maxY = Math.max(maxY, yVal);
      }
    });
    
    if (minY === maxY) {
      minY = minY * 0.95;
      maxY = maxY * 1.05;
    }
    
    // Draw the line
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokeWidth;
    ctx.beginPath();
    
    data.forEach((d, i) => {
      let xVal;
      if (typeof d[xKey] === 'object' && d[xKey].getTime) {
        xVal = d[xKey].getTime();
      } else {
        xVal = d[xKey];
      }
      const yVal = parseFloat(d[yKey]);
      
      if (!isNaN(yVal)) {
        // Scale to canvas
        const x = ml + (xVal - minX) / (maxX - minX) * (canvas.width - ml - mr);
        const y = (canvas.height - mb) - (yVal - minY) / (maxY - minY) * (canvas.height - mt - mb);
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
    });
    
    ctx.stroke();
    
    // Add price labels
    ctx.fillStyle = '#000';
    ctx.textAlign = 'right';
    ctx.fillText(maxY.toFixed(2), ml - 5, mt + 5);
    ctx.fillText(minY.toFixed(2), ml - 5, canvas.height - mb + 5);
  },
  
  // Mark creation functions
  line: function(data, options) {
    return {
      _type: 'line',
      data: data,
      options: options
    };
  },
  
  barY: function(data, options) {
    return {
      _type: 'barY',
      data: data,
      options: options
    };
  },
  
  cell: function(data, options) {
    return {
      _type: 'cell',
      data: data,
      options: options
    };
  },
  
  text: function(data, options) {
    return {
      _type: 'text',
      data: data,
      options: options
    };
  }
};

// Export the Plot object
window.Plot = Plot;