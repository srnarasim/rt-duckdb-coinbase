// Observable Plot library
// This is a minimal implementation to make the app work
// In a real app, you would import the full library from a CDN

const Plot = {
  plot: function(options) {
    const { marks, x, y, height, width } = options;
    
    // Create a canvas element for the plot
    const canvas = document.createElement('canvas');
    canvas.width = width || 600;
    canvas.height = height || 400;
    
    // Get the 2D context
    const ctx = canvas.getContext('2d');
    
    // Draw a simple chart background
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw axes
    ctx.strokeStyle = '#000';
    ctx.beginPath();
    ctx.moveTo(50, 20);
    ctx.lineTo(50, canvas.height - 30);
    ctx.lineTo(canvas.width - 20, canvas.height - 30);
    ctx.stroke();
    
    // Add y-axis label
    if (y && y.label) {
      ctx.save();
      ctx.translate(15, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillStyle = '#000';
      ctx.fillText(y.label, 0, 0);
      ctx.restore();
    }
    
    // Draw data if available
    if (marks && marks.length > 0 && marks[0].data) {
      const data = marks[0].data;
      if (data.length > 1) {
        const xKey = marks[0].x;
        const yKey = marks[0].y;
        
        // Find min/max values for scaling
        let minY = Infinity;
        let maxY = -Infinity;
        let minX = new Date(data[0][xKey]).getTime();
        let maxX = new Date(data[data.length - 1][xKey]).getTime();
        
        data.forEach(d => {
          const yVal = parseFloat(d[yKey]);
          minY = Math.min(minY, yVal);
          maxY = Math.max(maxY, yVal);
        });
        
        // Add some padding
        minY = minY * 0.95;
        maxY = maxY * 1.05;
        
        // Draw the line
        ctx.strokeStyle = '#3498db';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        data.forEach((d, i) => {
          const xVal = new Date(d[xKey]).getTime();
          const yVal = parseFloat(d[yKey]);
          
          // Scale to canvas
          const x = 50 + (xVal - minX) / (maxX - minX) * (canvas.width - 70);
          const y = (canvas.height - 30) - (yVal - minY) / (maxY - minY) * (canvas.height - 50);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        
        ctx.stroke();
        
        // Add price labels
        ctx.fillStyle = '#000';
        ctx.textAlign = 'right';
        ctx.fillText(maxY.toFixed(2), 45, 25);
        ctx.fillText(minY.toFixed(2), 45, canvas.height - 35);
      }
    }
    
    return canvas;
  }
};

// Export the Plot object
window.Plot = Plot;